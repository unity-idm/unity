# Repository Guidelines

## Project Structure & Module Organization
- Source: Java modules under `*/src/main/java`; resources in `*/src/main/resources`
- Tests: `*/src/test/java` per module; cross‑module tests live in `integration-tests/`
- Packaging: `distribution/` assembles runnable bundles; artifacts land in `*/target/`
- Notable modules: `engine`, `engine-api`, `storage(-api)`, `std-plugins`, `rest`, `rest-admin`, `saml`, `oauth`, `vaadin-*`, `web-upman`, `unity-rest-api`, `documentation`, `console`

## Build, Test, and Development Commands
- Full build with unit tests: `mvn -T 1C clean install -Dunity.selenium.opts=--headless=new -Dgpg.skip=true` (parallel)
- Full build without unit tests: `mvn -T 1C clean install -DskipTests -Dgpg.skip=true` (parallel)
- Module build: `mvn -pl engine -am package -Dgpg.skip=true` (builds `engine` and dependencies)
- Unit tests: `mvn test` or `mvn -Dtest=ClassNameTest test -Dgpg.skip=true` (runs `*Test`)
- Integration tests: `mvn -pl integration-tests -am test -Dgpg.skip=true` (Selenium/JUnit; requires browser drivers/headless env)
- Whenever you are running full build w/ or w/o tests, redirect the output of the build to a file. In case the build fails, examine an output file to find the root cause, and address the issue. This is to optimize context window usage. Delete the output file when it is no longer needed.

## Coding Style & Naming Conventions & Gudeslines
- Language: Java 17; one tab indentation; UTF‑8 encoding
- Maximum line length: 120 characters
- Naming: classes `PascalCase`, methods/fields `camelCase`, constants `UPPER_SNAKE_CASE`
- New packages: use `io.imunity`
- Imports: organize and avoid wildcards; keep visibility minimal
- Remove unused imports
- Extract larger blocks of code into well-named focused methods to enhance readability, maintainability, and testability of your code base
- The name of a function or a class should be inversely proportional to the size of the scope that contains it
- A variable name should be proportional to the size of the scope that contains it
- Favor private access modifiers, if not possible, then use default 'package' access. Fallback to public only in the last resort.
- Use Java Records (`record`) for immutable data transfer objects (DTOs)
- Favor immutability for objects where appropriate, especially for DTOs and configuration
- Include comments only for complex logic
- Strongly prefer a **package-by-feature** structure over package-by-layer

  **Example:** **PREFER THIS (Package-by-Feature)**
    ```
    io.imunity
      ├── posts                    # Feature: Posts
      │   ├── PostController.java  # Controller for Posts
      │   ├── PostService.java     # Service logic for Posts
      │   ├── PostRepository.java  # Data access for Posts
      │   ├── Post.java            # Domain/Entity for Posts
      │   └── dto                  # Data Transfer Objects specific to Posts
      │       ├── PostCreateRequest.java
      │       └── PostSummaryResponse.java
      │
      ├── users                    # Feature: Users
      │   ├── UserController.java
      │   ├── UserService.java
      │   ├── UserRepository.java
      │   └── User.java
      │
      └── common                   # Optional: Truly shared utilities/config
          └── exception
              └── ResourceNotFoundException.java
    ```
  **AVOID THIS (Package-by-Layer):**
    ```
    com.example.application
    ├── controller
    │   ├── PostController.java
    │   └── UserController.java
    │
    ├── service
    │   ├── PostService.java
    │   └── UserService.java
    │
    ├── repository
    │   ├── PostRepository.java
    │   └── UserRepository.java
    │
    └── model (or domain/entity)
        ├── Post.java
        └── User.java
    ```

## Testing Guidelines 
- Frameworks: JUnit 5, AssertJ, Mockito; Selenium for UI/integration in `integration-tests/`
- Locations: unit tests beside code in each module; browser‑level tests only in `integration-tests/`
- Coverage: JaCoCo configured; add tests for new logic and regressions
- Naming: unit tests `*Test`; prefer descriptive test method names
- Examples: run a single class `mvn -Dtest=MyServiceTest test`
- Test Method Naming: Use the "should" prefix for test method names followed by a descriptive name of what the test is verifying. For example, use `shouldReturnUserWhenValidIdProvided()` instead of `testGetUserById()`
- Test Structure: Use the given/when/then pattern (BDD style) for structuring test methods instead of Arrange/Act/Assert. 
- All new services, parsers, and transformation logic must have comprehensive test coverage
- All tests must pass before considering implementation complete
- Use parameterized tests for testing multiple scenarios
- In the case of parameterized tests, make the input argument a record with builder. The goal is to have the definition of Arguments cristal clear in terms of readability
- No Java Reflections in Tests: Avoid using Java reflections in autogenerated unit tests. Instead, use proper constructor injection, builder patterns, or factory methods to create test objects. Reflections make tests harder to understand, maintain, and can break when code changes
- Testing is not optional — it's a mandatory part of every development 

## Commit & Pull Request Guidelines
- Commits: prefix with issue key when applicable (e.g., `UY-1527: fix NPE`); concise, imperative mood
- PRs: include summary, linked issues, affected modules, test notes; add screenshots for Vaadin/UI changes
- CI hygiene: lint locally, ensure `mvn -T 1C -DskipTests=false verify` passes before requesting review

## Security & Configuration Tips
- Do not commit secrets or local configs; prefer environment variables and example files
- Git ignores: `target/`, IDE metadata, and test logs are already excluded; keep it that way
- Vaadin: frontend is built via Maven plugin; no manual `npm` steps required unless developing Vaadin components

