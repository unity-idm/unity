window.testCall = function() { window.alert('Works!') }

window.testCall2 = function(self) { self.$server.showError('Fido registration failed', 'ABC') }

/**
 * Triggers FIDO authenticator registration process on client side. Called from BE.
 * @param key Registration request ID
 * @param options Registration options.
 */
window.createCredentials = function(key, options, self) {
	try {
		const convertedOptions = convertOptions(JSON.parse(options));
		if (self.$server.clearExcludedCredentials)
			delete convertedOptions.excludeCredentials;
		navigator.credentials.create({
			publicKey: convertedOptions
		}).then(promise => {
			const convertedPromise = convertPromise(promise);
			self.$server.finalizeRegistration(key, JSON.stringify(convertedPromise));
		}).catch(err => {
			self.$server.showError("Fido registration failed", err.message);
		});
	} catch (err) {
		self.$server.showInternalError("Fido registration failed", err.message);
	}
}

/**
 * Triggers FIDO authenticator authentication process on client side. Called from BE.
 * @param key Authentication request ID
 * @param options Registration options.
 */
window.getCredentials = function(key, options, self) {
	try {
		const convertedOptions = convertOptions(JSON.parse(options));
		navigator.credentials.get({
			publicKey: convertedOptions.publicKeyCredentialRequestOptions
		}).then(promise => {
			const convertedPromise = convertPromise(promise);
			self.$server.finalizeAuthentication(key, JSON.stringify(convertedPromise));
		}).catch(err => {
			self.$server.showError("Fido authentication failed", err.message);
		});
	} catch (err) {
		self.$server.showInternalError("Fido authentication failed", err.message);
	}
}

/**
 * Coverts String representation of registration/authentication options received from BE to Arrays acceptable by FIDO authenticators.
 * @param options Registration or authentication options generated by BE
 * @returns {*} Converted options
 */
function convertOptions(options) {

	if (options.publicKeyCredentialRequestOptions) {
		const challenge = options.publicKeyCredentialRequestOptions.challenge.replace(/-/g, "+").replace(/_/g, "/");
		options.publicKeyCredentialRequestOptions.challenge = Uint8Array.from(atob(challenge), c => c.charCodeAt(0));

		const allowCredentials = options.publicKeyCredentialRequestOptions.allowCredentials && options.publicKeyCredentialRequestOptions.allowCredentials.map(credential => {
			const credId = credential.id.replace(/-/g, "+").replace(/_/g, "/");
			credential.id = Uint8Array.from(atob(credId), c => c.charCodeAt(0));
			return credential;
		});
		options.publicKeyCredentialRequestOptions.allowCredentials = allowCredentials;
	} else {

		const challenge = options.challenge.replace(/-/g, "+").replace(/_/g, "/");
		options.challenge = Uint8Array.from(atob(challenge), c => c.charCodeAt(0));

		const userid = options.user.id.replace(/-/g, "+").replace(/_/g, "/");
		options.user.id = Uint8Array.from(atob(userid), c => c.charCodeAt(0));

		const excludeCredentials = options.excludeCredentials && options.excludeCredentials.map(credential => {
			const credId = credential.id.replace(/-/g, "+").replace(/_/g, "/");
			credential.id = Uint8Array.from(atob(credId), c => c.charCodeAt(0));
			return credential;
		});
		options.excludeCredentials = excludeCredentials;
	}

	return options;
}

/**
 * Covert response fields received from FIDO authenticator to Base64Url encoded String acceptable by BE
 * @param promise Promise returned by FIDO authenticator
 * @returns {{response: {clientDataJSON: *, attestationObject: *}, id: *, type: *, clientExtensionResults: *}} Converted promise.
 */
function convertPromise(promise) {
	let clientExtensionResults = {};

	try {
		clientExtensionResults = promise.getClientExtensionResults();
	} catch (e) {
		console.error('getClientExtensionResults failed', e);
	}

	if (promise.response.attestationObject) {
		return {
			type: promise.type,
			id: promise.id,
			response: {
				attestationObject: coerceToBase64Url(promise.response.attestationObject),
				clientDataJSON: coerceToBase64Url(promise.response.clientDataJSON),
			},
			clientExtensionResults
		};
	}
	if (promise.response.authenticatorData) {
		return {
			type: promise.type,
			id: promise.id,
			response: {
				authenticatorData: coerceToBase64Url(promise.response.authenticatorData),
				clientDataJSON: coerceToBase64Url(promise.response.clientDataJSON),
				signature: coerceToBase64Url(promise.response.signature),
				userHandle: promise.response.userHandle && coerceToBase64Url(promise.response.userHandle),
			},
			clientExtensionResults
		};
	}
}

/**
 * Converts arays to Base64Url encoded String.
 * @param thing Array or ArrayBuffer to be converted.
 * @returns {string} String value
 */
function coerceToBase64Url(thing) {
	// Array or ArrayBuffer to Uint8Array
	if (Array.isArray(thing)) {
		thing = Uint8Array.from(thing);
	}

	if (thing instanceof ArrayBuffer) {
		thing = new Uint8Array(thing);
	}

	// Uint8Array to base64
	if (thing instanceof Uint8Array) {
		var str = "";
		var len = thing.byteLength;

		for (var i = 0; i < len; i++) {
			str += String.fromCharCode(thing[i]);
		}
		thing = window.btoa(str);
	}

	if (typeof thing !== "string") {
		throw new Error("could not coerce to string");
	}

	// base64 to base64url
	// NOTE: "=" at the end of challenge is optional, strip it off here
	thing = thing.replace(/\+/g, "-").replace(/\//g, "_").replace(/=*$/g, "");

	return thing;
}