[[endp-oauth-as]]
=== OAuth 2 Authorization Server and OpenId Connect endpoints

Endpoint 1 type:: +OAuth2Authz+
Binding :: Web
Exposed paths:: +/oauth2-authz+

Endpoint 2 type:: +OAuth2Token+
Binding:: RESTful (CXF)
Exposed paths:: +/token+, +/userinfo+, +/jwk+, +/tokeninfo+, +.well-known/openid-configuration+, +/revoke+


The OAuth 2 endpoints expose a functionality of a generic Authorization Server with a support for the OpenID
Connect specification. The _code_, _implicit_, _client credentials_ and _hybrid_ flows are supported.    

The functionality is provided by two Unity endpoints, which shouldn't be mixed with endpoints in OAuth sense 
which are equivalent to particular paths exposed by Unity endpoints. The first Unity endpoint, +OAuth2Authz+,
exposes the OAuth authorization endpoint functionality. It is a web endpoint. It is used by end-users and 
the authentication of this endpoint should be configured so that OAuth users can authenticate themselves.

The second Unity endpoint, +OAuth2Token+, supports all remaining OAuth endpoints, including the most important 
_token endpoint_. The authentication settings of this endpoint should allow for authenticating OAuth clients accessing
the +/token+ path as required by OAuth specification. Note however that some of the operations needs to 
be authorized/authenticated by providing an OAuth access token only and this fact is handled internally - 
nothing has to be configured. Also two of the paths require neither 
authentication nor access token: +/jwk+ and +.well-known/openid-configuration+. This is also handled automatically. 

==== Configuration

Both OAuth endpoints create a pair, both must use the same configuration file. Configuration example:

----
unity.oauth2.as.issuerUri=https://example.com:2443/oauth2-token
unity.oauth2.as.signingCredential=MAIN

unity.oauth2.as.clientsGroup=/oauth-clients
unity.oauth2.as.usersGroup=/oauth-users
unity.oauth2.as.translationProfile=oauthOutputProfile

unity.oauth2.as.scopes.1.name=scope1
unity.oauth2.as.scopes.1.description=Provides access to base info
unity.oauth2.as.scopes.1.attributes.1=cn
unity.oauth2.as.scopes.1.attributes.2=o
unity.oauth2.as.scopes.1.attributes.3=email
---- 
 
The issuer should be equal to the base URL of the OAuth token endpoint in order to be compatible with OpenID Connect 
Discovery specification. 

OAuth clients are configured as regular Unity entities. To make an ordinary entity an OAuth client one must 
place it in the configured OAuth clients groups (+/oauth-clients+ in the above example). Additionally the
client:

 - must have a credential so it can authenticate at the token endpoint in the way it was configured 
 (typically a password credential),
 - must possess the +sys:oauth:allowedGrantFlows+ attribute (in OAuth clients group) with allowed flows,
 - must possess the +sys:oauth:allowedReturnURI+ attribute (in OAuth clients group) with allowed return URI(s),
 - can have logo and/or displayed name OAuth attributes assigned to improve client's presentation during user's consent.
 - should have an attribute +sys:oauth:clientType+ specifying whether the client is confidential or public. By
 default client is assumed to be confidential, if the attribute is unset.
 
OAuth users must belong to a group specified in the configuration file. If no restrictions are required the '/' group
can be used. In case that there are different groups of users for different OAuth clients, those groups can be 
configured with client's attribute +sys:oauth:groupForClient+.  
 
OAuth scopes should be defined next. Each scope includes a list of Unity attributes (use the Unity name) that should be
exposed when the client asks for the scope and the user gives her consent. 

Finally an output translation profile can be configured. It is highly useful to map Unity's internal attribute names 
to names used by OAauth consumers. Standard OAuth/OIDC attribute names can be found in the OIDC specification: 
http://openid.net/specs/openid-connect-core-1_0.html#StandardClaims

Note that currently Unity requires you to configure all profiles and assign attributes to them manually.

The options for both endpoints (besides the standard options for all Web endpoints) are:

include::ref-oauthASProperties.txt[]

==== OpenID Connect

Unity supports OpenID Connect (OIDC) protocol nearly out of the box. The only requirement to enable OIDC 
is to define a scope with a special name +openid+. Typically the +openid+ scope has no attributes assigned. 

Clients requesting the +openid+ scope trigger OpenID Connect compatibility mode. In this mode the OIDC _id token_ 
is generated and returned in the implicit grant from the authorization endpoint or in the
code grant from the token endpoint.  
    
==== Usage

Unity as Authorization Server usage is mostly regulated with the OAuth or OIDC specifications. In short the client
redirects the user's browser to the authorization endpoint. There user should accept the client's request and 
Unity redirects the user back to the client. Depending on the flow used, the client receives an OAuth _access token_
immediately (the _implicit_ or _hybrid_ flows) or has to ask Unity's token endpoint about it (the _code_ flow). 
The _access token_ is then used by the client to access resources owned by the user. 

==== Token refresh

Unity can be configured to support the standard OAuth token refresh. See +refreshTokenValidity+ option description
for allowed modes. When refresh is enabled, then client receives a _refresh token_ along with an _access token_. 
The refresh token can be used to receive a new _acceess token_ from the token endpoint. 
The client can refresh _access token_ only with the same or reduced set of OAuth scopes as were bound 
to the original token. Refresh may be only performed by an authenticated client and the client must be the same 
as the one requesting the original _access token_. User information (claims) associated with the token is updated
at token refresh time. 

==== Token validation

At this point the OAuth specification doesn't specify how the access token presented to a resource server can be
validated. This missing step of the specification results from a common use case when a Resource Server and 
Authorization Server are the same. With Unity this is not the case so the Resource Server needs to contact Unity to 
verify if the received _access token_ is genuine and valid.

To validate an _access token_, a client (any, not necessarily the 'OAuth client') has to send a GET request to the 
+/tokeninfo+ path at the OAuth token endpoint. 

'''

+@Path("/tokeninfo")+ +
+@Authorization("Bearer access token")+ +
+@GET+ +

Returns status of a given access token, which must be provided in the Authorization header according to 
the RFC 6750). If the token is invalid then the HTTP 401 error is returned (see RFC 6750, section 3.1). If the token
is valid then the following JSON document is returned:  

----
{
  "sub": "subject id",
  "client_id": "client id",
  "exp": "12345678",
  "scope": ["scope1", "scope2"]
}
----

[NOTE]
This Unity endpoint can be also used to issue an access token which subsequently can be used as a simple credential
(mostly suitable for RESTful clients) to access Unity. Such approach is similar to the use of the JWT authentication
and <<endp-rest-jwt>>. The differences are that the Unity's JWT tokens can be obtained in a much
easier way then an OAuth access token. On the other hand JWT tokens can be used only with Unity, 
other services will neither issue nor validate them.

==== Token exchange
Unity supports token exchange according to https://tools.ietf.org/html/draft-ietf-oauth-token-exchange-08 specification. 
For this purpose a special grant type +urn:ietf:params:oauth:grant-type:token-exchange+ is used.

The token exchange process can be described in a simplified way:

 - Client A receives an _access token A_ from Unity. 
 - Client A gives the obtained _access token A_ to Resource Provider B (to authorize itself).
 - Resource Provider B wants to play a role of client -- Client B -- and access Resource Provider C. 
 To do so Client B exchanges the _access token A_ for a new _access token B_ 
 which can be used to obtain data from Resource Provider C. The exchange is supported by Unity token endpoint.

There are several conditions that must be met to perform a successful exchange:

 - Only an _access token_ which was issued with a special scope +token-exchange+ can be exchanged. 
 - Only the +urn:ietf:params:oauth:token-type:access_token+ token type exchange can be used as +subject_token_type+.
 - Only the original scopes or their subset can can be requested for the exchanged scope.
 - Audience parameter in exchange request is mandatory and must contain Unity username of the new _access token_ owner 
 (and must be the same as the +client_id+ parameter).  
 - _id token_ can be issued only if +requested_token_type+ is equal to +urn:ietf:params:oauth:token-type:id_token+ 
 and scopes contain +openid+. 
 - Exchange may be only performed by an authenticated Unity client.

Sample exchange request parameters:

----
client_id=oauth-client2
client_secret=secretPass
grant_type=urn:ietf:params:oauth:grant-type:token-exchange 
audience=oauth-client2
subject_token=ZCrlkMyxzhJ0CyQlskOsIgkcDqjW51ViZko0bopHzfM \ # This token was received from the initial client 
subject_token_type=urn:ietf:params:oauth:token-type:access_token
requested_token_type=urn:ietf:params:oauth:token-type:id_token
scope="openid profile read-tasks" 
----



==== Revocation and logout

The path +/revoke+ can be used to revoke an access token which was previously issued. This endpoint
is implemented according to the RFC 7009, with the following Unity specifics: 

. The +token_type_hint+ is a mandatory argument, must be always provided (in RFC it is optional). THe allowed values
  are +access_token+ and +refresh_token+.
. The endpoint access is not authenticated - or better said the access is authorized implicitly by providing
  a valid token to be revoked. The +client_id+ must be always given.
   
Typical usage:

----
POST /.../revoke HTTP/1.1
Host: ... 
Content-Type: application/x-www-form-urlencoded
   
token=45ghiukldjahdnhzdauz&client_id=oauth-client&token_type_hint=refresh_token
----

Besides the standard token revocation, it is also possible to request token's owner logout (disposal of the SSO session)
together with token revocation. To be able to perform this operation, the client must request and obtain a special
OAuth scope: +single-logout+. Having this scope, token revocation can be used to logout the token owner
by adding the following form parameter to the request: +logout=true+.
 
==== Dynamic token validity enhancement

Unity allows for enhancing access token validity in effect of a successful request to the token info or user info endpoint
authorized with the token in question. This feature is very useful in case of state less systems where login "session" management
is reduced to access token verification.   

To enable this feature set accessToken validity to a proper short time (e.g. 30 minutes) - equal to the intended inactive login session
time. Additionally set +extendAccessTokenValidityUpTo+ to the intended longest session time (e.g. 12 hours). Then the actively used
access token can be valid for up to 12 hours, but will automatically expire after 30 minutes without use.


==== Public and native clients, PKCE

Unity supports _Proof Key for Code Exchange by OAuth Public Clients OAuth 2.0 for Native Apps_ 
(PKCE for short, RFC 7636) and _OAuth 2.0 for Native Apps_ profile (RFC 8252). 
The features are activated for clients marked as +PUBLIC+ by the
clientType attribute on the client entity. Setting client to PUBLIC causes the following consequences:

* PKCE is mandatory
* IP (v4&v6) based loopback redirections to any port are available, regardless of the port set in authorized return URI.
Note that the path must still match exactly.
* The +http+ scheme can be used in case of IP based loopback redirect, even if +https+ is configured in authorized return URI.
* Consent screen acceptance can not be saved - it is always presented.

See the aformentioned RFCs for details on how to use PKCE, 
and what forms of return redirections are available for native clients.



